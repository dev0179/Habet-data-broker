import eventlet
eventlet.monkey_patch()

from flask import Flask, request, jsonify
from flask_socketio import SocketIO, emit
from flask_cors import CORS
import subprocess
import logging
import time
import threading
import serial
import math

# ======================== CONFIGURATION ========================
SERIAL_PORT = 'COM9'  # Adjust to your telemetry device port
SERIAL_BAUDRATE = 115200

ROTATOR_MODEL = '603'          # Yaesu G5500 rotator model number
ROTATOR_PORT = '/dev/ttyUSB0'  # Adjust as necessary

WEB_SOCKET_PORT = 5053

# Ground station (Fixed Reference Point)
LAT_S = 42.02698670969771
LON_S = -93.6535530849385
ALT_S = 0.279  # in km

# WGS-84 Ellipsoid Constants
A = 6378.137  # km (semi-major axis)
B = 6356.752  # km (semi-minor axis)
E2 = 1 - (B**2 / A**2)  # Square of eccentricity

# ======================== FLASK & SOCKETIO SETUP ========================
app = Flask(__name__)
CORS(app)
socketio = SocketIO(app, cors_allowed_origins="*", async_mode="eventlet")

# ======================== LOGGING SETUP ========================
logging.basicConfig(filename='rotator.log', level=logging.INFO,
                    format='%(asctime)s - %(message)s')

# Shared variable for azimuth & elevation
latest_rotation = {"azimuth": 0, "elevation": 0}

# ======================== ROTATOR CONTROL FUNCTIONS ========================
def execute_rotctl_command(command):
    """Executes a rotctl command and returns the output."""
    try:
        full_cmd = f"rotctl -m {ROTATOR_MODEL} -r {ROTATOR_PORT} {command}"
        result = subprocess.run(full_cmd, shell=True, capture_output=True, text=True)
        return result.stdout.strip()
    except Exception as e:
        logging.error(f"[ERROR] rotctl command failed: {e}")
        return None

def update_rotator(azimuth, elevation):
    """Sends azimuth and elevation commands to the rotator."""
    if azimuth is not None and elevation is not None:
        execute_rotctl_command(f'P {azimuth} {elevation}')
        logging.info(f"Rotator commanded to Az: {azimuth}, El: {elevation}")

# ======================== LLA TO ECEF & AZIMUTH/ELEVATION CALCULATIONS ========================
def lla_to_ecef(lat, lon, alt):
    """Converts Latitude, Longitude, Altitude (LLA) to Earth-Centered Earth-Fixed (ECEF)."""
    lat, lon = math.radians(lat), math.radians(lon)
    N = A / math.sqrt(1 - E2 * math.sin(lat)**2)
    X = (N + alt) * math.cos(lat) * math.cos(lon)
    Y = (N + alt) * math.cos(lat) * math.sin(lon)
    Z = ((B**2 / A**2) * N + alt) * math.sin(lat)
    return X, Y, Z

def ecef_to_enu(V, lat_s, lon_s):
    """Converts ECEF vector to East-North-Up (ENU) coordinates."""
    lat_s, lon_s = math.radians(lat_s), math.radians(lon_s)
    R = [
        [-math.sin(lon_s), math.cos(lon_s), 0],
        [-math.sin(lat_s) * math.cos(lon_s), -math.sin(lat_s) * math.sin(lon_s), math.cos(lat_s)],
        [math.cos(lat_s) * math.cos(lon_s), math.cos(lat_s) * math.sin(lon_s), math.sin(lat_s)]
    ]
    return [sum(R[i][j] * V[j] for j in range(3)) for i in range(3)]

def compute_az_el(lat_t, lon_t, alt_t):
    """Computes azimuth and elevation angles for pointing the rotator."""
    alt_t /= 1000  # Convert altitude to km

    # Compute ECEF coordinates
    Xs, Ys, Zs = lla_to_ecef(LAT_S, LON_S, ALT_S)
    Xt, Yt, Zt = lla_to_ecef(lat_t, lon_t, alt_t)

    # Compute line-of-sight (LOS) vector
    V = [Xt - Xs, Yt - Ys, Zt - Zs]

    # Convert LOS to ENU coordinates
    ENU = ecef_to_enu(V, LAT_S, LON_S)

    # Compute azimuth
    az = math.degrees(math.atan2(ENU[0], ENU[1]))
    if az < 0:
        az += 360  # Normalize azimuth

    # Compute elevation
    el = math.degrees(math.atan2(ENU[2], math.sqrt(ENU[0]**2 + ENU[1]**2)))

    return az, el

latest_data = {
    "time": None,
    "lat": None,
    "lon": None,
    "alt": None,
    "vx": None,
    "vy": None,
    "vz": None,
    "temperature": None,
    "pressure": None,
    "humidity": None,
    "other": None
}
data_lock = threading.Lock()
# ======================== SERIAL READING THREAD ========================
def serial_reader():
    """Reads telemetry data from the serial port and updates the rotator."""
    global latest_data

    try:
        ser = serial.Serial(SERIAL_PORT, SERIAL_BAUDRATE, timeout=1)
        print(f"[INFO] Connected to serial port {SERIAL_PORT}")
        logging.info(f"[INFO] Connected to serial port {SERIAL_PORT}")
    except Exception as e:
        logging.error(f"[ERROR] Cannot open serial port {SERIAL_PORT}: {e}")
        return

    while True:
        try:
            line = ser.readline().decode('utf-8').strip()
            if line.startswith('$$HAR'):
                print(f"[DEBUG] Raw line: {line}")
                parts = line.split(',')

                if len(parts) >= 11:  # Ensure proper length
                    with data_lock:
                        latest_data = {
                            "time": parts[1].strip(),
                            "lat": parts[2].strip(),
                            "lon": parts[3].strip(),
                            "alt": parts[4].strip(),
                            "vx": parts[5].strip(),
                            "vy": parts[6].strip(),
                            "vz": parts[7].strip(),
                            "temperature": parts[8].strip(),
                            "pressure": parts[9].strip(),
                            "humidity": parts[10].strip(),
                            "other": parts[11].strip() if len(parts) > 11 else None
                        }
                    try:
                        lat_t, lon_t, alt_t = float(parts[2]), float(parts[3]), float(parts[4])

                        # Compute azimuth & elevation
                        az, el = compute_az_el(lat_t, lon_t, alt_t)
                        print(f"[DEBUG] Azimuth: {az:.2f}°, Elevation: {el:.2f}°")
                        # Update shared variable
                        latest_rotation = {"azimuth": az, "elevation": el}

                        # Send command to rotator
                        update_rotator(az, el)

                        # Emit data to WebSocket clients
                        socketio.emit('status_update', latest_rotation)

                        logging.info(f"[INFO] Updated rotation to Az: {az:.2f}°, El: {el:.2f}°")
                    except ValueError:
                        logging.warning(f"[WARNING] Invalid telemetry data: {parts}")

            time.sleep(0.5)

        except Exception as e:
            logging.error(f"[ERROR] Error reading/parsing serial: {e}")

# ======================== ROTATOR STATUS THREAD ========================
def rotator_status_thread():
    """Background task to emit real-time rotator status."""
    while True:
        try:
            status = execute_rotctl_command('p')
            if status:
                lines = status.strip().splitlines()
                if len(lines) >= 2:
                    az, el = float(lines[0]), float(lines[1])
                    socketio.emit('status_update', {"azimuth": az, "elevation": el})
                    logging.info(f"[INFO] Status Update → Az: {az:.2f}°, El: {el:.2f}°")
                else:
                    logging.warning(f"[WARNING] Unexpected rotator status format: {status}")

        except Exception as e:
            logging.error(f"[ERROR] Error retrieving rotator status: {e}")

        time.sleep(1)  # Emit every second


@socketio.on('connect')
def handle_connect():
    """Handle new WebSocket connections."""
    emit('connection', {'status': 'connected'})

# ======================== MAIN EXECUTION ========================
if __name__ == '__main__':
    # Start serial reader and rotator status threads
    threading.Thread(target=serial_reader, daemon=True).start()
    socketio.start_background_task(rotator_status_thread)

    # Start WebSocket Server
    socketio.run(app, host='0.0.0.0', port=WEB_SOCKET_PORT)
